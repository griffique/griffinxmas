"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var react_1 = require("react");
var safeHasOwnProperty_1 = __importDefault(require("./shared/safeHasOwnProperty"));
var createCbSetterErrorProxy_1 = __importDefault(require("./shared/createCbSetterErrorProxy"));
var useHandlerSetterRef_1 = __importDefault(require("./shared/useHandlerSetterRef"));
var assignDragEventOnMount = function (targetRef, handlerRef, eventName) {
    (0, react_1.useEffect)(function () {
        var cb = function (dragEvent) {
            if (handlerRef && handlerRef.current) {
                handlerRef.current(dragEvent);
            }
        };
        if (targetRef.current) {
            targetRef.current.addEventListener(eventName, cb);
        }
        return function () {
            if (targetRef.current) {
                targetRef.current.removeEventListener(eventName, cb);
            }
        };
    }, []);
};
/**
 * Returns an object of callback setters to handle the drag-related events.
 * It accepts a DOM ref representing the events target (where attach the events to).
 *
 * Returned callback setters: `onDrag`, `onDrop`, `onDragEnter`, `onDragEnd`, `onDragExit`, `onDragLeave`,
 * `onDragOver`, `onDragStart`;
 */
var useDragEvents = function (targetRef, setDraggable) {
    if (setDraggable === void 0) { setDraggable = true; }
    var _a = (0, useHandlerSetterRef_1.default)(), onDrag = _a[0], setOnDrag = _a[1];
    var _b = (0, useHandlerSetterRef_1.default)(), onDrop = _b[0], setOnDrop = _b[1];
    var _c = (0, useHandlerSetterRef_1.default)(), onDragEnter = _c[0], setOnDragEnter = _c[1];
    var _d = (0, useHandlerSetterRef_1.default)(), onDragEnd = _d[0], setOnDragEnd = _d[1];
    var _e = (0, useHandlerSetterRef_1.default)(), onDragExit = _e[0], setOnDragExit = _e[1];
    var _f = (0, useHandlerSetterRef_1.default)(), onDragLeave = _f[0], setOnDragLeave = _f[1];
    var _g = (0, useHandlerSetterRef_1.default)(), onDragOver = _g[0], setOnDragOver = _g[1];
    var _h = (0, useHandlerSetterRef_1.default)(), onDragStart = _h[0], setOnDragStart = _h[1];
    if (targetRef !== null && !(0, safeHasOwnProperty_1.default)(targetRef, 'current')) {
        return (0, createCbSetterErrorProxy_1.default)('Unable to assign any drag event to the given ref');
    }
    (0, react_1.useEffect)(function () {
        if (setDraggable && targetRef.current && !targetRef.current.hasAttribute('draggable')) {
            targetRef.current.setAttribute('draggable', String(true));
        }
    }, []);
    assignDragEventOnMount(targetRef, onDrag, 'drag');
    assignDragEventOnMount(targetRef, onDrop, 'drop');
    assignDragEventOnMount(targetRef, onDragEnter, 'dragenter');
    assignDragEventOnMount(targetRef, onDragEnd, 'dragend');
    assignDragEventOnMount(targetRef, onDragExit, 'dragexit');
    assignDragEventOnMount(targetRef, onDragLeave, 'dragleave');
    assignDragEventOnMount(targetRef, onDragOver, 'dragover');
    assignDragEventOnMount(targetRef, onDragStart, 'dragstart');
    return Object.freeze({
        onDrag: setOnDrag,
        onDrop: setOnDrop,
        onDragEnter: setOnDragEnter,
        onDragEnd: setOnDragEnd,
        onDragExit: setOnDragExit,
        onDragLeave: setOnDragLeave,
        onDragOver: setOnDragOver,
        onDragStart: setOnDragStart,
    });
};
exports.default = useDragEvents;
