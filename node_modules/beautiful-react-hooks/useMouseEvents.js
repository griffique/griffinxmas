"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var useHandlerSetterRef_1 = __importDefault(require("./shared/useHandlerSetterRef"));
var createCbSetterErrorProxy_1 = __importDefault(require("./shared/createCbSetterErrorProxy"));
var safeHasOwnProperty_1 = __importDefault(require("./shared/safeHasOwnProperty"));
var assignEventOnMount_1 = __importDefault(require("./shared/assignEventOnMount"));
/**
 * Returns a frozen object of callback setters to handle the mouse events.<br/>
 * It accepts a DOM ref representing the events target. <br/>
 * If a target is not provided the events will be globally attached to the document object.
 * <br/>
 * ### Shall the `useMouseEvents` callbacks replace the standard mouse handler props?
 *
 * **They shall not!**<br />
 * **useMouseEvents is meant to be used to abstract more complex hooks that need to control mouse**, for instance:
 * a drag n drop hook.<br />
 * Using useMouseEvents handlers instead of the classic props approach it's just as bad as it sounds since you'll
 * lose the React SyntheticEvent performance boost.<br />
 * If you were doing something like the following:
 */
var useMouseEvents = function (targetRef) {
    if (targetRef === void 0) { targetRef = null; }
    var _a = (0, useHandlerSetterRef_1.default)(), onMouseDownHandler = _a[0], setOnMouseDown = _a[1];
    var _b = (0, useHandlerSetterRef_1.default)(), onMouseEnterHandler = _b[0], setOnMouseEnter = _b[1];
    var _c = (0, useHandlerSetterRef_1.default)(), onMouseLeaveHandler = _c[0], setOnMouseLeave = _c[1];
    var _d = (0, useHandlerSetterRef_1.default)(), onMouseMoveHandler = _d[0], setOnMouseMove = _d[1];
    var _e = (0, useHandlerSetterRef_1.default)(), onMouseOutHandler = _e[0], setOnMouseOut = _e[1];
    var _f = (0, useHandlerSetterRef_1.default)(), onMouseOverHandler = _f[0], setOnMouseOver = _f[1];
    var _g = (0, useHandlerSetterRef_1.default)(), onMouseUpHandler = _g[0], setOnMouseUp = _g[1];
    if (targetRef !== null && !(0, safeHasOwnProperty_1.default)(targetRef, 'current')) {
        return (0, createCbSetterErrorProxy_1.default)('Unable to assign any mouse event to the given ref');
    }
    (0, assignEventOnMount_1.default)(targetRef, onMouseDownHandler, 'mousedown');
    (0, assignEventOnMount_1.default)(targetRef, onMouseEnterHandler, 'mouseenter');
    (0, assignEventOnMount_1.default)(targetRef, onMouseLeaveHandler, 'mouseleave');
    (0, assignEventOnMount_1.default)(targetRef, onMouseMoveHandler, 'mousemove');
    (0, assignEventOnMount_1.default)(targetRef, onMouseOutHandler, 'mouseout');
    (0, assignEventOnMount_1.default)(targetRef, onMouseOverHandler, 'mouseover');
    (0, assignEventOnMount_1.default)(targetRef, onMouseUpHandler, 'mouseup');
    return Object.freeze({
        onMouseDown: setOnMouseDown,
        onMouseEnter: setOnMouseEnter,
        onMouseLeave: setOnMouseLeave,
        onMouseMove: setOnMouseMove,
        onMouseOut: setOnMouseOut,
        onMouseOver: setOnMouseOver,
        onMouseUp: setOnMouseUp,
    });
};
exports.default = useMouseEvents;
